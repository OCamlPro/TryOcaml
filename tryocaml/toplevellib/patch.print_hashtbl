diff -C 3 -r ocaml-3.12.1/toplevel/genprintval.ml ocaml-3.12.1-orig/toplevel/genprintval.ml
*** ocaml-3.12.1/toplevel/genprintval.ml	2012-01-03 14:11:29.453539000 +0100
--- ocaml-3.12.1-orig/toplevel/genprintval.ml	2009-10-26 11:53:16.000000000 +0100
***************
*** 45,53 ****
      val install_printer :
            Path.t -> Types.type_expr -> (formatter -> t -> unit) -> unit
      val remove_printer : Path.t -> unit
-     val install_printer2 :
-           Path.t -> Types.type_expr -> (Env.t -> Types.type_expr -> t -> Outcometree.out_value) -> unit
-     val remove_printer2 : Path.t -> unit
      val outval_of_untyped_exception : t -> Outcometree.out_value
      val outval_of_value :
            int -> int ->
--- 45,50 ----
***************
*** 55,66 ****
            Env.t -> t -> type_expr -> Outcometree.out_value
    end
  
- 
-     (* An abstract type *)
- 
- let abstract_type =
-   Ctype.newty (Tconstr (Pident (Ident.create "abstract"), [], ref Mnil))
- 
  module Make(O : OBJ)(EVP : EVALPATH with type value = O.t) = struct
  
      type t = O.t
--- 52,57 ----
***************
*** 170,198 ****
      and tree_of_label =
        tree_of_qualified (fun lid env -> (Env.lookup_label lid env).lbl_res)
  
!     (* The main printing function *)
! 
! 
!     let printers2 = ref []
  
!     let install_printer2 path ty fn =
!       printers2 := (path, ty, fn) :: !printers2
  
!     let remove_printer2 path =
!       let rec remove = function
!       | [] -> raise Not_found
!       | (p, ty, fn as printer) :: rem ->
!           if Path.same p path then rem else printer :: remove rem in
!       printers2 := remove !printers2
! 
!     let find_printer2 env ty obj =
!       let rec find = function
!       | [] -> raise Not_found
!       | (name, sch, printer) :: remainder ->
!           if Ctype.moregeneral env false sch ty
!           then printer env ty obj
!           else find remainder
!       in find !printers2
  
      let outval_of_value max_steps max_depth check_depth env obj ty =
  
--- 161,172 ----
      and tree_of_label =
        tree_of_qualified (fun lid env -> (Env.lookup_label lid env).lbl_res)
  
!     (* An abstract type *)
  
!     let abstract_type =
!       Ctype.newty (Tconstr (Pident (Ident.create "abstract"), [], ref Mnil))
  
!     (* The main printing function *)
  
      let outval_of_value max_steps max_depth check_depth env obj ty =
  
***************
*** 205,213 ****
          try
            find_printer env ty obj
          with Not_found ->
-         try
-           find_printer2 env ty obj
-         with Not_found ->
            match (Ctype.repr ty).desc with
            | Tvar ->
                Oval_stuff "<poly>"
--- 179,184 ----
diff -C 3 -r ocaml-3.12.1/toplevel/genprintval.mli ocaml-3.12.1-orig/toplevel/genprintval.mli
*** ocaml-3.12.1/toplevel/genprintval.mli	2012-01-03 14:11:41.053538998 +0100
--- ocaml-3.12.1-orig/toplevel/genprintval.mli	2002-04-18 09:27:47.000000000 +0200
***************
*** 17,24 ****
  open Types
  open Format
  
- val abstract_type : Types.type_expr
- 
  module type OBJ =
    sig
      type t
--- 17,22 ----
***************
*** 43,51 ****
      val install_printer :
            Path.t -> Types.type_expr -> (formatter -> t -> unit) -> unit
      val remove_printer : Path.t -> unit
-     val install_printer2 :
-           Path.t -> Types.type_expr -> (Env.t -> Types.type_expr -> t -> Outcometree.out_value) -> unit
-     val remove_printer2 : Path.t -> unit
      val outval_of_untyped_exception : t -> Outcometree.out_value
      val outval_of_value :
            int -> int ->
--- 41,46 ----
diff -C 3 -r ocaml-3.12.1/toplevel/opttopdirs.ml ocaml-3.12.1-orig/toplevel/opttopdirs.ml
*** ocaml-3.12.1/toplevel/opttopdirs.ml	2012-01-03 14:09:43.103539003 +0100
--- ocaml-3.12.1-orig/toplevel/opttopdirs.ml	2010-01-22 13:48:24.000000000 +0100
***************
*** 97,106 ****
  
  (* Install, remove a printer *)
  
! type 'a printer_type2 = Format.formatter -> Types.type_expr -> 'a -> unit
! type 'a printer_type1 = Format.formatter -> 'a -> unit
! type 'a printer_type0 = 'a -> unit
! 
  
  let match_printer_type ppf desc typename =
    let (printer_type, _) =
--- 97,104 ----
  
  (* Install, remove a printer *)
  
! type 'a printer_type_new = Format.formatter -> 'a -> unit
! type 'a printer_type_old = 'a -> unit
  
  let match_printer_type ppf desc typename =
    let (printer_type, _) =
***************
*** 124,135 ****
      let (path, desc) = Env.lookup_value lid !toplevel_env in
      let (ty_arg, is_old_style) =
        try
!         (match_printer_type ppf desc "printer_type2", 2)
!       with Ctype.Unify _ ->
!       try
!         (match_printer_type ppf desc "printer_type1", 1)
        with Ctype.Unify _ ->
!         (match_printer_type ppf desc "printer_type0", 0) in
      (ty_arg, path, is_old_style)
    with
    | Not_found ->
--- 122,130 ----
      let (path, desc) = Env.lookup_value lid !toplevel_env in
      let (ty_arg, is_old_style) =
        try
!         (match_printer_type ppf desc "printer_type_new", false)
        with Ctype.Unify _ ->
!         (match_printer_type ppf desc "printer_type_old", true) in
      (ty_arg, path, is_old_style)
    with
    | Not_found ->
***************
*** 144,157 ****
    try
      let (ty_arg, path, is_old_style) = find_printer_type ppf lid in
      let v = eval_path path in
!     match is_old_style with
!       | 0 -> install_printer path ty_arg
!           (fun formatter repr -> Obj.obj v (Obj.obj repr))
!       | 1 -> install_printer path ty_arg
!           (fun formatter repr -> Obj.obj v (Obj.obj repr))
!       | 2 -> install_printer2 path ty_arg
!         (fun formatter ty repr -> Obj.obj v formatter ty (Obj.obj repr))
!       | _ -> assert false
    with Exit -> ()
  
  let dir_remove_printer ppf lid =
--- 139,150 ----
    try
      let (ty_arg, path, is_old_style) = find_printer_type ppf lid in
      let v = eval_path path in
!     let print_function =
!       if is_old_style then
!         (fun formatter repr -> Obj.obj v (Obj.obj repr))
!       else
!         (fun formatter repr -> Obj.obj v formatter (Obj.obj repr)) in
!     install_printer path ty_arg print_function
    with Exit -> ()
  
  let dir_remove_printer ppf lid =
diff -C 3 -r ocaml-3.12.1/toplevel/topdirs.ml ocaml-3.12.1-orig/toplevel/topdirs.ml
*** ocaml-3.12.1/toplevel/topdirs.ml	2012-01-03 14:24:11.473539015 +0100
--- ocaml-3.12.1-orig/toplevel/topdirs.ml	2010-01-22 13:48:24.000000000 +0100
***************
*** 135,144 ****
  
  (* Install, remove a printer *)
  
! type 'a printer_type2 = Env.t -> Types.type_expr -> 'a -> Outcometree.out_value
! type 'a printer_type1 = Format.formatter -> 'a -> unit
! type 'a printer_type0 = 'a -> unit
! 
  
  let match_printer_type ppf desc typename =
    let (printer_type, _) =
--- 135,142 ----
  
  (* Install, remove a printer *)
  
! type 'a printer_type_new = Format.formatter -> 'a -> unit
! type 'a printer_type_old = 'a -> unit
  
  let match_printer_type ppf desc typename =
    let (printer_type, _) =
***************
*** 162,173 ****
      let (path, desc) = Env.lookup_value lid !toplevel_env in
      let (ty_arg, is_old_style) =
        try
!         (match_printer_type ppf desc "printer_type2", 2)
!       with Ctype.Unify _ ->
!       try
!         (match_printer_type ppf desc "printer_type1", 1)
        with Ctype.Unify _ ->
!         (match_printer_type ppf desc "printer_type0", 0) in
      (ty_arg, path, is_old_style)
    with
    | Not_found ->
--- 160,168 ----
      let (path, desc) = Env.lookup_value lid !toplevel_env in
      let (ty_arg, is_old_style) =
        try
!         (match_printer_type ppf desc "printer_type_new", false)
        with Ctype.Unify _ ->
!         (match_printer_type ppf desc "printer_type_old", true) in
      (ty_arg, path, is_old_style)
    with
    | Not_found ->
***************
*** 182,194 ****
    try
      let (ty_arg, path, is_old_style) = find_printer_type ppf lid in
      let v = eval_path path in
!     match is_old_style with
!       | 0 -> install_printer path ty_arg
!           (fun formatter repr -> Obj.obj v (Obj.obj repr))
!       | 1 -> install_printer path ty_arg
!           (fun formatter repr -> Obj.obj v (Obj.obj repr))
!       | 2 -> install_printer2 path ty_arg (Obj.obj v)
!       | _ -> assert false
    with Exit -> ()
  
  let dir_remove_printer ppf lid =
--- 177,188 ----
    try
      let (ty_arg, path, is_old_style) = find_printer_type ppf lid in
      let v = eval_path path in
!     let print_function =
!       if is_old_style then
!         (fun formatter repr -> Obj.obj v (Obj.obj repr))
!       else
!         (fun formatter repr -> Obj.obj v formatter (Obj.obj repr)) in
!     install_printer path ty_arg print_function
    with Exit -> ()
  
  let dir_remove_printer ppf lid =
diff -C 3 -r ocaml-3.12.1/toplevel/topdirs.mli ocaml-3.12.1-orig/toplevel/topdirs.mli
*** ocaml-3.12.1/toplevel/topdirs.mli	2012-01-03 14:15:48.883539002 +0100
--- ocaml-3.12.1-orig/toplevel/topdirs.mli	2002-04-18 09:27:47.000000000 +0200
***************
*** 27,35 ****
  val dir_untrace : formatter -> Longident.t -> unit
  val dir_untrace_all : formatter -> unit -> unit
  
! type 'a printer_type2 = Env.t -> Types.type_expr -> 'a -> Outcometree.out_value
! type 'a printer_type1 = Format.formatter -> 'a -> unit
! type 'a printer_type0 = 'a -> unit
  
  (* For topmain.ml. Maybe shouldn't be there *)
  val load_file : formatter -> string -> bool
--- 27,34 ----
  val dir_untrace : formatter -> Longident.t -> unit
  val dir_untrace_all : formatter -> unit -> unit
  
! type 'a printer_type_new = Format.formatter -> 'a -> unit
! type 'a printer_type_old = 'a -> unit
  
  (* For topmain.ml. Maybe shouldn't be there *)
  val load_file : formatter -> string -> bool
diff -C 3 -r ocaml-3.12.1/toplevel/toploop.ml ocaml-3.12.1-orig/toplevel/toploop.ml
*** ocaml-3.12.1/toplevel/toploop.ml	2012-01-03 15:09:33.483538999 +0100
--- ocaml-3.12.1-orig/toplevel/toploop.ml	2009-01-25 23:46:15.000000000 +0100
***************
*** 95,102 ****
  
  let install_printer = Printer.install_printer
  let remove_printer = Printer.remove_printer
- let install_printer2 = Printer.install_printer2
- let remove_printer2 = Printer.remove_printer2
  
  (* Hooks for parsing functions *)
  
--- 95,100 ----
***************
*** 437,510 ****
    toplevel_env := Compile.initial_env();
    Sys.interactive := false;
    use_silently ppf name
- 
- let rec find_type env ty =
-   match (Ctype.repr ty).desc with
-     | Tconstr(path, ty_list, _) ->
-       begin
-       let decl = Env.find_type path env in
-       match decl with
-         | {type_kind = Type_abstract; type_manifest = None} ->
-           begin
-             match ty_list with
-                 [ty1; ty2] -> (ty1, ty2)
-               | _ -> raise Not_found
-           end
-         | {type_kind = Type_abstract; type_manifest = Some body} ->
-           find_type env
-             ( Ctype.apply env decl.type_params body ty_list )
-         | _ -> raise Not_found
-       end
-     | _ -> raise Not_found
- 
- let find_type env ty =
-   try
-     find_type env ty
-   with _ ->
-     (Genprintval.abstract_type, Genprintval.abstract_type)
- 
- let stringers = [
-   Predef.type_int, (fun i -> string_of_int (Obj.magic i));
-   Predef.type_float, (fun i -> string_of_float (Obj.magic i));
-   Predef.type_string, (fun i -> Obj.magic i);
-   Predef.type_char, (fun i -> String.make 1 (Obj.magic i));
-   Predef.type_int32, (fun i -> Int32.to_string (Obj.magic i));
-   Predef.type_int64, (fun i -> Int64.to_string (Obj.magic i));
- ]
- 
- let rec find_stringer env ty list =
-   match list with
-       [] -> raise Not_found
-     | (ty', stringer) :: tail ->
-       if Ctype.moregeneral env false ty' ty then stringer else find_stringer env ty tail
- 
- let print_hashtbl env ty t =
-   let (t1, t2) = find_type env ty in
-   let stringer =
-     try
-       find_stringer env t1 stringers
-     with _ -> (fun _ -> "<too complex>")
-   in
-   let list = ref [] in
-   Hashtbl.iter (fun k v ->
-     list := (Oide_ident (stringer k), outval_of_value env (Obj.repr v) t2) :: !list
-   ) t;
-   Oval_record (List.rev !list)
- 
- 
- (*
-  #install_printer Toploop.print_hashtbl;;
- 
-  let of_list list =
-   let t = Hashtbl.create 13 in
-   List.iter (fun (k,v) -> Hashtbl.add t k v) list;
-  t;;
- 
- of_list [1,1; 2,2 ];;
- of_list [ "a", [1]; "b", [1;2] ];;
- of_list [ (1,1) , [1] ];;
- 
- 
- 
- 
- *)
--- 435,437 ----
diff -C 3 -r ocaml-3.12.1/toplevel/toploop.mli ocaml-3.12.1-orig/toplevel/toploop.mli
*** ocaml-3.12.1/toplevel/toploop.mli	2012-01-03 14:36:10.343539000 +0100
--- ocaml-3.12.1-orig/toplevel/toploop.mli	2007-12-04 14:38:58.000000000 +0100
***************
*** 72,81 ****
    Path.t -> Types.type_expr -> (formatter -> Obj.t -> unit) -> unit
  val remove_printer : Path.t -> unit
  
- val outval_of_value : Env.t -> Obj.t -> Types.type_expr -> Outcometree.out_value
- val install_printer2 : Path.t -> Types.type_expr -> (Env.t -> Types.type_expr -> Obj.t -> Outcometree.out_value) -> unit
- val remove_printer2 : Path.t -> unit
- 
  val max_printer_depth: int ref
  val max_printer_steps: int ref
  
--- 72,77 ----
***************
*** 114,121 ****
  (* Used by Trace module *)
  
  val may_trace : bool ref
- 
- val print_hashtbl :
-   Env.t ->
-   Types.type_expr ->
-   ('a, 'b) Hashtbl.t -> Outcometree.out_value
--- 110,112 ----
